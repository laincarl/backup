<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Document</title>
</head>

<body>
    <script type="text/javascript">
    var a = 1;
    var b = '1';
    var c = true;
    var d;
    /*三种创建函数的方法
    区别：
    1.解释器会先读取函数声明，并使其在任何代码之前都可以背调用
    2.函数表达式只有在解释器执行到这一行才会解释执行,只能在函数表达式之后调用函数，否则会报不是函数的错误*/
    //函数表达式		
    f();
    var e = function() {
        console.log('执行e');
    };
    e();
    //函数声明
    function f() {
        console.log('执行f');
    };
    //自执行函数,函数匿名，直接用括号包起来，主要用于创建一个新的作用域，在此作用域内声明的变量，不会和其它作用域内的变量冲突或混淆，大多是以匿名函数方式存在，且立即自动执行。
    console.log('全局环境的a:' + a);
    (function(a) {
        console.log('自执行函数内的a:' + a)
    })(5);
    //函数构造法,每次执行的时候都会创建一个函数实例，性能不好
    var g = new Function('a', "console.log('执行函数g'+a)");
    g(a);
    var h = new Date();
    console.log('a:' + typeof(a));
    console.log('b:' + typeof(b));
    console.log('c:' + typeof(c));
    console.log('d:' + typeof(d));
    console.log('e:' + e.prototype + typeof(e));
    console.log('f:' + typeof(f));
    console.log('g:' + g + 'type:' + typeof(f));
    console.log('h:' + h + 'type:' + typeof(h));
    console.log('八进制0123：' + 0123);
    console.log(e instanceof Function);
    var name = "The Window";
　　var object = {
　　　　name : "My Object",
　　　　getNameFunc : function(){
　　　　　　var that = this;
　　　　　　return function(){
　　　　　　　　return that.name;
　　　　　　};
　　　　}
　　};
　　alert(object.getNameFunc()());
    </script>
</body>

</html>
